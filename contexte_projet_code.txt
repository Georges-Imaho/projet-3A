### STRUCTURE COMPL√àTE DU PROJET ###
projet_sauvetage/
    requirements.txt
    .gitignore
    main.py
    code_to_text.py
    notebook/
        Data_Load.ipynb
        test_LSTM.ipynb
        BlackScholes.ipynb
        projet-3A/
            requirements.txt
            .gitignore
            main.py
            code_to_text.py
            notebook/
                Data_Load.ipynb
                test_LSTM.ipynb
                BlackScholes.ipynb
                projet-3A/
            data/
                train_data.csv
                test_data.csv
            src/
                deep_hedger.py
                hedging_engine.py
                analytics_models.py
                market_simulator.py
    data/
        train_data.csv
        test_data.csv
    src/
        deep_hedger.py
        hedging_engine.py
        analytics_models.py
        market_simulator.py

==================================================

#### CONTENU DU FICHIER : main.py ####
def bite ():
#### FIN DU FICHIER : main.py ####

#### CONTENU DU FICHIER : code_to_text.py ####
import os
import json
import nbformat

# --- Configuration ---
# Dossiers et fichiers syst√®me √† ignorer
IGNORE_LIST = {
    '.git', '__pycache__', 'venv', '.venv', 'node_modules', 
    '.ipynb_checkpoints', '.DS_Store', 'contexte_projet.txt', 
    'contexte_projet_notebooks.txt', 'contexte_projet_code.txt', # On s'ignore soi-m√™me pour √©viter une boucle
    '.idea', '.vscode'
}

OUTPUT_FILE = "contexte_projet_code.txt"

def extract_notebook_content(filepath):
    """
    Lit un fichier .ipynb avec nbformat et extrait uniquement 
    les cellules de type CODE et MARKDOWN.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            nb = nbformat.read(f, as_version=4)
            content = []
            for i, cell in enumerate(nb.cells):
                cell_type = cell.cell_type.upper()
                source = cell.source
                content.append(f"--- Cellule {i} [{cell_type}] ---\n{source}\n")
            return "\n".join(content)
    except Exception as e:
        return f"[Erreur lors de la lecture du Notebook : {e}]\n"

def extract_py_content(filepath):
    """
    Lit simplement le contenu textuel d'un fichier .py
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"[Erreur lors de la lecture du fichier Python : {e}]\n"

def generate_context_file(root_dir, output_file):
    with open(output_file, 'w', encoding='utf-8') as f_out:
        
        # --- 1. G√âN√âRATION DE L'ARBORESCENCE COMPL√àTE ---
        f_out.write("### STRUCTURE COMPL√àTE DU PROJET ###\n")
        
        for root, dirs, files in os.walk(root_dir):
            dirs[:] = [d for d in dirs if d not in IGNORE_LIST]
            
            level = root.replace(root_dir, '').count(os.sep)
            indent = ' ' * 4 * level
            
            f_out.write(f"{indent}{os.path.basename(root)}/\n")
            
            sub_indent = ' ' * 4 * (level + 1)
            for f in files:
                if f not in IGNORE_LIST:
                    f_out.write(f"{sub_indent}{f}\n")
        
        f_out.write("\n" + "="*50 + "\n\n")

        # --- 2. EXTRACTION DU CONTENU (.ipynb ET .py) ---
        for root, dirs, files in os.walk(root_dir):
            dirs[:] = [d for d in dirs if d not in IGNORE_LIST]
            
            for file in files:
                full_path = os.path.join(root, file)
                relative_path = os.path.relpath(full_path, root_dir)
                
                # Gestion des Notebooks
                if file.endswith('.ipynb'):
                    f_out.write(f"#### CONTENU DU FICHIER : {relative_path} ####\n")
                    f_out.write(extract_notebook_content(full_path))
                    f_out.write(f"\n#### FIN DU FICHIER : {relative_path} ####\n\n")
                
                # Gestion des fichiers Python standards
                elif file.endswith('.py'):
                    f_out.write(f"#### CONTENU DU FICHIER : {relative_path} ####\n")
                    f_out.write(extract_py_content(full_path))
                    f_out.write(f"\n#### FIN DU FICHIER : {relative_path} ####\n\n")

if __name__ == "__main__":
    chemin_actuel = os.getcwd()
    print(f"Analyse du projet dans : {chemin_actuel}")
    print(f"1. G√©n√©ration de l'arborescence compl√®te.")
    print(f"2. Extraction du code des fichiers .ipynb et .py.")
    
    generate_context_file(chemin_actuel, OUTPUT_FILE)
    
    print(f"Termin√© ! Le fichier '{OUTPUT_FILE}' a √©t√© g√©n√©r√©.")
#### FIN DU FICHIER : code_to_text.py ####

#### CONTENU DU FICHIER : notebook/Data_Load.ipynb ####
--- Cellule 0 [CODE] ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import sys

# --- 1. CONFIGURATION DU CHEMIN ---
# Le notebook est dans "notebook/", les modules dans "src/"
# On ajoute le dossier racine (..) au path pour pouvoir faire "from src..."
project_root = os.path.abspath('..')
if project_root not in sys.path:
    sys.path.append(project_root)

# --- 2. CR√âATION DU DOSSIER DATA ---
DATA_DIR = os.path.join(project_root, "data")
if not os.path.exists(DATA_DIR):
    os.makedirs(DATA_DIR)
    print(f"üìÇ Dossier cr√©√© : {DATA_DIR}")
else:
    print(f"üìÇ Dossier donn√©es d√©tect√© : {DATA_DIR}")

# --- 3. IMPORTS DES MODULES DU PROJET ---
try:
    # Attention : v√©rifie si ton fichier s'appelle market_simulator.py ou market_simulators.py
    # D'apr√®s ton arborescence, c'est le singulier : market_simulator
    from src.market_simulator import MarketSimulator
    from src.analytics_models import BlackScholesOracle
    print("‚úÖ Imports des modules src r√©ussis !")
except ImportError as e:
    print(f"‚ùå Erreur d'import : {e}")
    print("V√©rifie que les fichiers .py sont bien dans le dossier '../src/'")

# Config graphique
sns.set_theme(style="whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)

--- Cellule 1 [CODE] ---
# --- TEST VISUEL : SIMULATEUR DE MARCH√â (GBM) ---

# Param√®tres
S0 = 100       # Prix initial
T = 1.0        # 1 an
N_STEPS = 252  # Jours de bourse
N_PATHS = 10   # Nombre de courbes √† afficher

# Instanciation
sim = MarketSimulator(s0=S0, r=0.05, sigma=0.2)

# G√©n√©ration
paths = sim.simulate_gbm(steps=N_STEPS, n_paths=N_PATHS)

# Visualisation
plt.figure(figsize=(10, 6))
plt.plot(paths)
plt.title(f"Simulation de {N_PATHS} trajectoires (Mouvement Brownien G√©om√©trique)")
plt.xlabel("Jours de trading")
plt.ylabel("Prix ($)")
plt.axhline(y=S0, color='black', linestyle='--', label="Prix Initial")
plt.legend()
plt.show()

--- Cellule 2 [CODE] ---
# --- G√âN√âRATION DU DATASET (100 000 SC√âNARIOS) ---

N_SAMPLES = 100000
print(f"üöÄ G√©n√©ration de {N_SAMPLES} options...")

np.random.seed(42) # Reproductibilit√©

# 1. Inputs al√©atoires (X)
S = np.random.uniform(50, 150, N_SAMPLES)      # Spot Price
K = np.random.uniform(50, 150, N_SAMPLES)      # Strike Price
T = np.random.uniform(0.1, 2.0, N_SAMPLES)     # Maturit√© (ann√©es)
r = np.random.uniform(0.01, 0.05, N_SAMPLES)   # Taux (1% - 5%)
sigma = np.random.uniform(0.1, 0.5, N_SAMPLES) # Volatilit√© (10% - 50%)

# 2. Calcul du Label (Y) avec l'Oracle que tu viens de coder
# On calcule le prix du CALL
calls = BlackScholesOracle.get_price(S, K, T, r, sigma, option_type='call')

# 3. Cr√©ation du DataFrame
df = pd.DataFrame({
    'S': S, 'K': K, 'T': T, 'r': r, 'sigma': sigma,
    'call_price': calls
})

# Feature Engineering simple (utile pour l'analyse)
df['moneyness'] = df['S'] / df['K']

print("Aper√ßu des donn√©es g√©n√©r√©es :")
display(df.head())

--- Cellule 3 [CODE] ---
# --- SAUVEGARDE (TRAIN / TEST SPLIT) ---

# M√©lange des donn√©es
df = df.sample(frac=1, random_state=42).reset_index(drop=True)

# S√©paration 80% / 20%
split_idx = int(0.8 * len(df))
train_df = df.iloc[:split_idx]
test_df = df.iloc[split_idx:]

# Chemins de sauvegarde
train_path = os.path.join(DATA_DIR, "train_data.csv")
test_path = os.path.join(DATA_DIR, "test_data.csv")

train_df.to_csv(train_path, index=False)
test_df.to_csv(test_path, index=False)

print(f"‚úÖ Fichiers sauvegard√©s avec succ√®s !")
print(f"   Train : {train_path} ({len(train_df)} lignes)")
print(f"   Test  : {test_path} ({len(test_df)} lignes)")

--- Cellule 4 [CODE] ---
# --- ANALYSE DES DONN√âES G√âN√âR√âES ---

fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# 1. Relation Prix Spot vs Prix Option
# On prend un √©chantillon al√©atoire de 2000 points pour ne pas surcharger le graph
sample = df.sample(2000) 
sns.scatterplot(
    data=sample, x='S', y='call_price', 
    hue='moneyness', palette='viridis', ax=axes[0]
)
axes[0].set_title("Prix Call vs Spot (Color√© par Moneyness)")
axes[0].set_xlabel("Spot Price ($)")
axes[0].set_ylabel("Call Price ($)")

# 2. Distribution des prix
sns.histplot(df['call_price'], bins=50, ax=axes[1], color='purple', kde=True)
axes[1].set_title("Distribution des Prix des Calls")
axes[1].set_xlabel("Prix du Call")

plt.tight_layout()
plt.show()

--- Cellule 5 [CODE] ---


#### FIN DU FICHIER : notebook/Data_Load.ipynb ####

#### CONTENU DU FICHIER : notebook/test_LSTM.ipynb ####
--- Cellule 0 [CODE] ---
import os
import sys
import shutil

# 1. NETTOYAGE : On supprime l'ancien dossier s'il existe pour √™tre s√ªr d'avoir la derni√®re version
if os.path.exists('projet-3A'):
    shutil.rmtree('projet-3A')
    print(" Ancien dossier supprim√©.")

# 2. CLONE : On t√©l√©charge la version √† jour
!git clone https://github.com/Georges-Imaho/projet-3A.git
print("‚úÖ D√©p√¥t clon√© avec succ√®s.")

# On se place dans le dossier
os.chdir('projet-3A')
# On ajoute le dossier courant au path pour que Python trouve le dossier 'src'
if os.getcwd() not in sys.path:
    sys.path.append(os.getcwd())

print("‚úÖ Environnement configur√©. Dossier actuel :", os.getcwd())

# --- 2. IMPORTS DES LIBRAIRIES ---
import torch
import torch.optim as optim
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm # Barre de chargement

# --- 3. IMPORTS DE TES MODULES PERSONNELS ---
try:
    from src.market_simulator import MarketSimulator
    from src.analytics_models import BlackScholesOracle
    from src.deep_hedger import DeepHedgingModel
    from src.hedging_engine import HedgingEngine
    print("‚úÖ Modules 'src' import√©s avec succ√®s !")
except ImportError as e:
    print(f"‚ùå Erreur d'import : {e}")
    print("V√©rifie que les fichiers sont bien pr√©sents dans le dossier src/ sur GitHub.")

# Configuration graphique
sns.set_theme(style="darkgrid")
plt.rcParams['figure.figsize'] = (12, 6)

--- Cellule 1 [CODE] ---
def prepare_batch(simulator, batch_size, T, steps, strike=100.0):
    # 1. Simulation HESTON (Inchang√©)
    paths, vols = simulator.simulate_heston(
        steps=steps, n_paths=batch_size, kappa=2.0, theta=0.04, xi=0.3, rho=-0.7
    )
    
    paths, vols = simulator.simulate_heston(
        steps=steps, n_paths=batch_size, kappa=2.0, theta=0.04, xi=0.3, rho=-0.7
    )
    
    # S√âCURIT√â : On remplace les valeurs <= 0 par un tout petit chiffre pour √©viter log(0)
    paths = np.maximum(paths, 1e-4)
    vols = np.maximum(vols, 1e-4)

    spot_paths = torch.tensor(paths.T, dtype=torch.float32)
    vol_paths = torch.tensor(vols.T, dtype=torch.float32)

    # ... (Reste du calcul des features identique) ...
    # Feature A: Moneyness
    log_moneyness = torch.log(spot_paths / strike)
    
    # Feature B: Time
    time_grid = torch.linspace(T, 0, steps+1)
    time_feature = time_grid.unsqueeze(0).repeat(batch_size, 1)
    
    # Feature C: Returns (Avec s√©curit√© NaN)
    zeros = torch.zeros((batch_size, 1))
    # On ajoute 1e-6 pour la stabilit√©
    log_returns = torch.diff(torch.log(spot_paths), dim=1)
    log_returns = torch.nan_to_num(log_returns, nan=0.0) # S√©curit√© ultime
    log_returns = torch.cat([zeros, log_returns], dim=1)
    
    # Feature D: Vol
    vol_feature = (vol_paths - 0.2) / 0.1 

    # V√©rifie bien l'ordre : Moneyness, Time, Vol, Returns
    inputs = torch.stack([log_moneyness, time_feature, vol_feature, log_returns], dim=-1)
    
    return spot_paths, inputs

--- Cellule 2 [CODE] ---
# --- PARAM√àTRES ---
S0 = 100; K = 100; T = 1.0; N_STEPS = 30
BATCH_SIZE = 256
LR = 0.001 

# --- CONFIGURATION ---
sim = MarketSimulator(s0=S0, r=0.0, sigma=0.2)
# input_dim=4 (Moneyness, Time, Vol, Returns)
model = DeepHedgingModel(input_dim=4, hidden_dim=32, output_dim=1) 
optimizer = optim.Adam(model.parameters(), lr=LR)
scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='min', factor=0.5, patience=50)

# Aversion au risque plus douce pour commencer
RISK_AVERSION = 1.0 
engine = HedgingEngine(model, optimizer, criterion=None, transaction_cost_pct=0.0, risk_aversion=RISK_AVERSION)

# --- CURRICULUM AVEC WARMUP ---
# (Debut, Fin, Co√ªt, Utiliser_MSE)
phases = [
    (0, 200, 0.0, True),       # WARMUP: Pas de frais, MSE Loss (Stabilisation)
    (200, 1000, 0.001, False), # PHASE 2: Petits frais, Entropic Loss
    (1000, 3000, 0.005, False) # PHASE 3: Vrais frais, Entropic Loss
]

history = []
pbar = tqdm(range(3000))

print("üöÄ D√©marrage (Warmup MSE -> Entropic)...")

for epoch in pbar:
    # 1. Configuration de la phase
    current_cost = 0.0
    use_mse = False
    for start, end, cost, mse_mode in phases:
        if start <= epoch < end:
            current_cost = cost
            use_mse = mse_mode
            break
            
    engine.cost_pct = current_cost
    
    # 2. Donn√©es
    spots, inputs = prepare_batch(sim, BATCH_SIZE, T, N_STEPS, strike=K)
    strikes = torch.full((BATCH_SIZE,), K)
    
    # 3. Premium Initial
    S0_b = spots[:, 0]; Vol0_b = inputs[:, 0, 2]
    bs_p = BlackScholesOracle.get_price(S0_b.numpy(), K, T, 0.0, Vol0_b.numpy(), 'call')
    init_prices = torch.tensor(bs_p, dtype=torch.float32)
    
    # 4. Train Step (Avec le flag use_mse)
    loss, mean_pnl = engine.train_step(spots, strikes, inputs, init_prices, use_mse=use_mse)
    
    if not np.isnan(loss):
        scheduler.step(loss)
        history.append(loss)
    
    if epoch % 10 == 0:
        mode_str = "MSE" if use_mse else "ENT"
        pbar.set_description(f"Ep {epoch}| {mode_str} | C:{current_cost*100:.1f}% | Loss:{loss:.2f} | PnL:{mean_pnl:.2f}")

plt.plot(history)
plt.title("Convergence (Warmup MSE puis Transition Entropique)")
plt.yscale('log')
plt.show()

--- Cellule 3 [CODE] ---
# --- PARAM√àTRES DU TEST ---
N_TEST_PATHS = 2048   # Un grand nombre pour avoir une stat fiable
TEST_BATCH_SIZE = 256 # On proc√®de par batch pour ne pas saturer la RAM
Strike_Test = 100.0

# Listes pour stocker les r√©sultats
all_ai_pnls = []
all_bs_pnls = []

print(f"üöÄ Lancement du Benchmark sur {N_TEST_PATHS} sc√©narios Heston...")

# On s'assure que le mod√®le est en mode √©valuation (fig√©)
model.eval()

# On utilise le moteur actuel pour le calcul de PnL (avec les frais de la Phase 3 !)
# Assure-toi que engine.cost_pct est bien r√©gl√© sur 0.5% (ou la valeur finale)
print(f"   Frais de transaction appliqu√©s : {engine.cost_pct * 100:.2f}%")

with torch.no_grad():
    # Boucle par batch pour g√©n√©rer N_TEST_PATHS
    for _ in tqdm(range(0, N_TEST_PATHS, TEST_BATCH_SIZE)):
        
        # 1. G√©n√©ration donn√©es Heston
        spots, inputs = prepare_batch(sim, TEST_BATCH_SIZE, T, N_STEPS, strike=Strike_Test)
        strikes = torch.full((TEST_BATCH_SIZE,), Strike_Test)
        
        # 2. Calcul du Premium Initial (BS) pour ce batch
        # C'est l'argent re√ßu au d√©part. N√©cessaire pour un PnL juste.
        S0 = spots[:, 0]
        Vol0 = inputs[:, 0, 2] # Volatilit√© initiale fournie par Heston
        
        initial_premiums_np = BlackScholesOracle.get_price(
            S=S0.numpy(), K=Strike_Test, T=T, r=0.0, sigma=Vol0.numpy(), option_type='call'
        )
        initial_premiums = torch.tensor(initial_premiums_np, dtype=torch.float32)
        
        # --- STRAT√âGIE IA ---
        ai_deltas = model(inputs)
        ai_pnl = engine._compute_pnl(spots, strikes, ai_deltas, T, initial_prices=initial_premiums)
        all_ai_pnls.extend(ai_pnl.numpy())
        
        # --- STRAT√âGIE BLACK-SCHOLES (BENCHMARK) ---
        # On recalcule le Delta BS dynamique pour chaque pas de temps
        # Vectorisation pour la vitesse :
        # inputs[:, :, 0] -> LogMoneyness (Pas besoin ici, on a spots)
        # inputs[:, :, 1] -> Time to maturity
        # inputs[:, :, 2] -> Volatilit√© Heston (On donne la vraie vol √† BS pour qu'il soit fort)
        
        bs_deltas_list = []
        for t in range(spots.shape[1]): # Boucle sur le temps (30 pas)
            S_t = spots[:, t].numpy()
            Vol_t = inputs[:, t, 2].numpy() # BS voit la vraie vol
            Time_t = inputs[:, t, 1].numpy()
            
            # Delta BS
            d = BlackScholesOracle.get_delta(S_t, Strike_Test, Time_t, r=0.0, sigma=Vol_t, option_type='call')
            bs_deltas_list.append(d)
            
        # Reconstitution forme [Batch, Time, 1]
        bs_deltas = torch.tensor(np.array(bs_deltas_list)).T.unsqueeze(-1).float()
        
        # Calcul PnL BS (avec les M√äMES frais que l'IA)
        bs_pnl = engine._compute_pnl(spots, strikes, bs_deltas, T, initial_prices=initial_premiums)
        all_bs_pnls.extend(bs_pnl.numpy())

# Conversion en arrays numpy pour l'analyse
all_ai_pnls = np.array(all_ai_pnls)
all_bs_pnls = np.array(all_bs_pnls)

# --- ANALYSE STATISTIQUE ---
mean_ai = np.mean(all_ai_pnls)
std_ai = np.std(all_ai_pnls)
mean_bs = np.mean(all_bs_pnls)
std_bs = np.std(all_bs_pnls)

# Ratio de victoire (Combien de fois l'IA fait mieux que BS ?)
# "Mieux" veut dire un PnL plus √©lev√© (moins de perte ou plus de gain)
wins = np.sum(all_ai_pnls > all_bs_pnls)
win_rate = (wins / len(all_ai_pnls)) * 100

print(f"\nüìä R√âSULTATS COMPARATIFS ({N_TEST_PATHS} sc√©narios)")
print("-" * 50)
print(f"Strat√©gie          | Mean PnL ($) | Std Dev (Risk) | Sharpe Simplifi√©")
print("-" * 50)
print(f"Black-Scholes      | {mean_bs:12.4f} | {std_bs:14.4f} | {mean_bs/std_bs:10.4f}")
print(f"Deep Hedging (IA)  | {mean_ai:12.4f} | {std_ai:14.4f} | {mean_ai/std_ai:10.4f}")
print("-" * 50)
print(f"üèÜ Win Rate de l'IA : {win_rate:.2f}% (L'IA bat BS sur {wins} sc√©narios)")

# --- VISUALISATION ---
plt.figure(figsize=(14, 7))

# Histogrammes superpos√©s
sns.histplot(all_bs_pnls, color='blue', alpha=0.4, label='Black-Scholes', kde=True, stat="density")
sns.histplot(all_ai_pnls, color='red', alpha=0.4, label='Deep Hedging (IA)', kde=True, stat="density")

# Lignes verticales pour les moyennes
plt.axvline(mean_bs, color='blue', linestyle='--', linewidth=2, label=f'Moyenne BS: {mean_bs:.2f}')
plt.axvline(mean_ai, color='red', linestyle='--', linewidth=2, label=f'Moyenne IA: {mean_ai:.2f}')
plt.axvline(0, color='black', linewidth=1) # Z√©ro PnL

plt.title(f"Distribution des PnL (Net de Frais) - {N_TEST_PATHS} Sc√©narios Heston", fontsize=16)
plt.xlabel("Profit & Loss ($)")
plt.ylabel("Densit√© de probabilit√©")
plt.legend()
plt.show()

--- Cellule 4 [CODE] ---


#### FIN DU FICHIER : notebook/test_LSTM.ipynb ####

#### CONTENU DU FICHIER : notebook/BlackScholes.ipynb ####
--- Cellule 0 [MARKDOWN] ---
# Black Scholes

--- Cellule 1 [CODE] ---
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

--- Cellule 2 [CODE] ---
def black_scholes_call(S, K, T, r, sigma):
    # 1. Calculate d1
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    
    # 2. Calculate d2
    d2 = d1 - sigma * np.sqrt(T)
    
    # 3. Apply the formula: C = S*N(d1) - K*exp(-rT)*N(d2)
    C = (S * norm.cdf(d1)) - (K * np.exp(-r * T) * norm.cdf(d2))
    
    return C

# Example usage:
spot = 100      # S
strike = 105    # K
time = 1        # T (1 year)
rate = 0.05     # r (5%)
vol = 0.2       # sigma (20%)

price = black_scholes_call(spot, strike, time, rate, vol)
print(f"The fair price of the Call Option (C) is: {price:.2f}")

--- Cellule 3 [CODE] ---
def simulate_stock_path(S0, T, r, sigma, steps):
    dt = T / steps
    # Generate random movements (Brownian Motion increments)
    W = np.random.standard_normal(steps) 
    W = np.cumsum(W) * np.sqrt(dt) # Cumulative sum to get the path
    
    time_steps = np.linspace(0, T, steps)
    # The Black-Scholes dynamic formula
    S_path = S0 * np.exp((r - 0.5 * sigma**2) * time_steps + sigma * W)
    
    return time_steps, S_path

# Visualizing 5 possible futures for the stock
plt.figure(figsize=(10, 6))
for i in range(5):
    t, path = simulate_stock_path(100, 1, 0.05, 0.2, 252)
    plt.plot(t, path)

plt.axhline(y=105, color='r', linestyle='--', label='Strike Price (K)')
plt.title("Simulated Stock Price Paths (S) vs Strike (K)")
plt.xlabel("Time (Years)")
plt.ylabel("Stock Price")
plt.legend()
plt.show()

#### FIN DU FICHIER : notebook/BlackScholes.ipynb ####

#### CONTENU DU FICHIER : notebook/projet-3A/main.py ####
def bite ():
#### FIN DU FICHIER : notebook/projet-3A/main.py ####

#### CONTENU DU FICHIER : notebook/projet-3A/code_to_text.py ####
import os
import json
import nbformat

# --- Configuration ---
# Dossiers et fichiers syst√®me √† ignorer
IGNORE_LIST = {
    '.git', '__pycache__', 'venv', '.venv', 'node_modules', 
    '.ipynb_checkpoints', '.DS_Store', 'contexte_projet.txt', 
    'contexte_projet_notebooks.txt', 'contexte_projet_code.txt', # On s'ignore soi-m√™me pour √©viter une boucle
    '.idea', '.vscode'
}

OUTPUT_FILE = "contexte_projet_code.txt"

def extract_notebook_content(filepath):
    """
    Lit un fichier .ipynb avec nbformat et extrait uniquement 
    les cellules de type CODE et MARKDOWN.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            nb = nbformat.read(f, as_version=4)
            content = []
            for i, cell in enumerate(nb.cells):
                cell_type = cell.cell_type.upper()
                source = cell.source
                content.append(f"--- Cellule {i} [{cell_type}] ---\n{source}\n")
            return "\n".join(content)
    except Exception as e:
        return f"[Erreur lors de la lecture du Notebook : {e}]\n"

def extract_py_content(filepath):
    """
    Lit simplement le contenu textuel d'un fichier .py
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"[Erreur lors de la lecture du fichier Python : {e}]\n"

def generate_context_file(root_dir, output_file):
    with open(output_file, 'w', encoding='utf-8') as f_out:
        
        # --- 1. G√âN√âRATION DE L'ARBORESCENCE COMPL√àTE ---
        f_out.write("### STRUCTURE COMPL√àTE DU PROJET ###\n")
        
        for root, dirs, files in os.walk(root_dir):
            dirs[:] = [d for d in dirs if d not in IGNORE_LIST]
            
            level = root.replace(root_dir, '').count(os.sep)
            indent = ' ' * 4 * level
            
            f_out.write(f"{indent}{os.path.basename(root)}/\n")
            
            sub_indent = ' ' * 4 * (level + 1)
            for f in files:
                if f not in IGNORE_LIST:
                    f_out.write(f"{sub_indent}{f}\n")
        
        f_out.write("\n" + "="*50 + "\n\n")

        # --- 2. EXTRACTION DU CONTENU (.ipynb ET .py) ---
        for root, dirs, files in os.walk(root_dir):
            dirs[:] = [d for d in dirs if d not in IGNORE_LIST]
            
            for file in files:
                full_path = os.path.join(root, file)
                relative_path = os.path.relpath(full_path, root_dir)
                
                # Gestion des Notebooks
                if file.endswith('.ipynb'):
                    f_out.write(f"#### CONTENU DU FICHIER : {relative_path} ####\n")
                    f_out.write(extract_notebook_content(full_path))
                    f_out.write(f"\n#### FIN DU FICHIER : {relative_path} ####\n\n")
                
                # Gestion des fichiers Python standards
                elif file.endswith('.py'):
                    f_out.write(f"#### CONTENU DU FICHIER : {relative_path} ####\n")
                    f_out.write(extract_py_content(full_path))
                    f_out.write(f"\n#### FIN DU FICHIER : {relative_path} ####\n\n")

if __name__ == "__main__":
    chemin_actuel = os.getcwd()
    print(f"Analyse du projet dans : {chemin_actuel}")
    print(f"1. G√©n√©ration de l'arborescence compl√®te.")
    print(f"2. Extraction du code des fichiers .ipynb et .py.")
    
    generate_context_file(chemin_actuel, OUTPUT_FILE)
    
    print(f"Termin√© ! Le fichier '{OUTPUT_FILE}' a √©t√© g√©n√©r√©.")
#### FIN DU FICHIER : notebook/projet-3A/code_to_text.py ####

#### CONTENU DU FICHIER : notebook/projet-3A/notebook/Data_Load.ipynb ####
--- Cellule 0 [CODE] ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import sys

# --- 1. CONFIGURATION DU CHEMIN ---
# Le notebook est dans "notebook/", les modules dans "src/"
# On ajoute le dossier racine (..) au path pour pouvoir faire "from src..."
project_root = os.path.abspath('..')
if project_root not in sys.path:
    sys.path.append(project_root)

# --- 2. CR√âATION DU DOSSIER DATA ---
DATA_DIR = os.path.join(project_root, "data")
if not os.path.exists(DATA_DIR):
    os.makedirs(DATA_DIR)
    print(f"üìÇ Dossier cr√©√© : {DATA_DIR}")
else:
    print(f"üìÇ Dossier donn√©es d√©tect√© : {DATA_DIR}")

# --- 3. IMPORTS DES MODULES DU PROJET ---
try:
    # Attention : v√©rifie si ton fichier s'appelle market_simulator.py ou market_simulators.py
    # D'apr√®s ton arborescence, c'est le singulier : market_simulator
    from src.market_simulator import MarketSimulator
    from src.analytics_models import BlackScholesOracle
    print("‚úÖ Imports des modules src r√©ussis !")
except ImportError as e:
    print(f"‚ùå Erreur d'import : {e}")
    print("V√©rifie que les fichiers .py sont bien dans le dossier '../src/'")

# Config graphique
sns.set_theme(style="whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)

--- Cellule 1 [CODE] ---
# --- TEST VISUEL : SIMULATEUR DE MARCH√â (GBM) ---

# Param√®tres
S0 = 100       # Prix initial
T = 1.0        # 1 an
N_STEPS = 252  # Jours de bourse
N_PATHS = 10   # Nombre de courbes √† afficher

# Instanciation
sim = MarketSimulator(s0=S0, r=0.05, sigma=0.2)

# G√©n√©ration
paths = sim.simulate_gbm(steps=N_STEPS, n_paths=N_PATHS)

# Visualisation
plt.figure(figsize=(10, 6))
plt.plot(paths)
plt.title(f"Simulation de {N_PATHS} trajectoires (Mouvement Brownien G√©om√©trique)")
plt.xlabel("Jours de trading")
plt.ylabel("Prix ($)")
plt.axhline(y=S0, color='black', linestyle='--', label="Prix Initial")
plt.legend()
plt.show()

--- Cellule 2 [CODE] ---
# --- G√âN√âRATION DU DATASET (100 000 SC√âNARIOS) ---

N_SAMPLES = 100000
print(f"üöÄ G√©n√©ration de {N_SAMPLES} options...")

np.random.seed(42) # Reproductibilit√©

# 1. Inputs al√©atoires (X)
S = np.random.uniform(50, 150, N_SAMPLES)      # Spot Price
K = np.random.uniform(50, 150, N_SAMPLES)      # Strike Price
T = np.random.uniform(0.1, 2.0, N_SAMPLES)     # Maturit√© (ann√©es)
r = np.random.uniform(0.01, 0.05, N_SAMPLES)   # Taux (1% - 5%)
sigma = np.random.uniform(0.1, 0.5, N_SAMPLES) # Volatilit√© (10% - 50%)

# 2. Calcul du Label (Y) avec l'Oracle que tu viens de coder
# On calcule le prix du CALL
calls = BlackScholesOracle.get_price(S, K, T, r, sigma, option_type='call')

# 3. Cr√©ation du DataFrame
df = pd.DataFrame({
    'S': S, 'K': K, 'T': T, 'r': r, 'sigma': sigma,
    'call_price': calls
})

# Feature Engineering simple (utile pour l'analyse)
df['moneyness'] = df['S'] / df['K']

print("Aper√ßu des donn√©es g√©n√©r√©es :")
display(df.head())

--- Cellule 3 [CODE] ---
# --- SAUVEGARDE (TRAIN / TEST SPLIT) ---

# M√©lange des donn√©es
df = df.sample(frac=1, random_state=42).reset_index(drop=True)

# S√©paration 80% / 20%
split_idx = int(0.8 * len(df))
train_df = df.iloc[:split_idx]
test_df = df.iloc[split_idx:]

# Chemins de sauvegarde
train_path = os.path.join(DATA_DIR, "train_data.csv")
test_path = os.path.join(DATA_DIR, "test_data.csv")

train_df.to_csv(train_path, index=False)
test_df.to_csv(test_path, index=False)

print(f"‚úÖ Fichiers sauvegard√©s avec succ√®s !")
print(f"   Train : {train_path} ({len(train_df)} lignes)")
print(f"   Test  : {test_path} ({len(test_df)} lignes)")

--- Cellule 4 [CODE] ---
# --- ANALYSE DES DONN√âES G√âN√âR√âES ---

fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# 1. Relation Prix Spot vs Prix Option
# On prend un √©chantillon al√©atoire de 2000 points pour ne pas surcharger le graph
sample = df.sample(2000) 
sns.scatterplot(
    data=sample, x='S', y='call_price', 
    hue='moneyness', palette='viridis', ax=axes[0]
)
axes[0].set_title("Prix Call vs Spot (Color√© par Moneyness)")
axes[0].set_xlabel("Spot Price ($)")
axes[0].set_ylabel("Call Price ($)")

# 2. Distribution des prix
sns.histplot(df['call_price'], bins=50, ax=axes[1], color='purple', kde=True)
axes[1].set_title("Distribution des Prix des Calls")
axes[1].set_xlabel("Prix du Call")

plt.tight_layout()
plt.show()

--- Cellule 5 [CODE] ---


#### FIN DU FICHIER : notebook/projet-3A/notebook/Data_Load.ipynb ####

#### CONTENU DU FICHIER : notebook/projet-3A/notebook/test_LSTM.ipynb ####
--- Cellule 0 [CODE] ---
import os
import sys
import shutil

# 1. NETTOYAGE : On supprime l'ancien dossier s'il existe pour √™tre s√ªr d'avoir la derni√®re version
if os.path.exists('projet-3A'):
    shutil.rmtree('projet-3A')
    print(" Ancien dossier supprim√©.")

# 2. CLONE : On t√©l√©charge la version √† jour
!git clone https://github.com/Georges-Imaho/projet-3A.git
print("‚úÖ D√©p√¥t clon√© avec succ√®s.")

# On se place dans le dossier
os.chdir('projet-3A')
# On ajoute le dossier courant au path pour que Python trouve le dossier 'src'
if os.getcwd() not in sys.path:
    sys.path.append(os.getcwd())

print("‚úÖ Environnement configur√©. Dossier actuel :", os.getcwd())

# --- 2. IMPORTS DES LIBRAIRIES ---
import torch
import torch.optim as optim
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm # Barre de chargement

# --- 3. IMPORTS DE TES MODULES PERSONNELS ---
try:
    from src.market_simulator import MarketSimulator
    from src.analytics_models import BlackScholesOracle
    from src.deep_hedger import DeepHedgingModel
    from src.hedging_engine import HedgingEngine
    print("‚úÖ Modules 'src' import√©s avec succ√®s !")
except ImportError as e:
    print(f"‚ùå Erreur d'import : {e}")
    print("V√©rifie que les fichiers sont bien pr√©sents dans le dossier src/ sur GitHub.")

# Configuration graphique
sns.set_theme(style="darkgrid")
plt.rcParams['figure.figsize'] = (12, 6)

--- Cellule 1 [CODE] ---
def prepare_batch(simulator, batch_size, T, steps, strike=100.0):
    # 1. Simulation HESTON (Inchang√©)
    paths, vols = simulator.simulate_heston(
        steps=steps, n_paths=batch_size, kappa=2.0, theta=0.04, xi=0.3, rho=-0.7
    )
    
    paths, vols = simulator.simulate_heston(
        steps=steps, n_paths=batch_size, kappa=2.0, theta=0.04, xi=0.3, rho=-0.7
    )
    
    # S√âCURIT√â : On remplace les valeurs <= 0 par un tout petit chiffre pour √©viter log(0)
    paths = np.maximum(paths, 1e-4)
    vols = np.maximum(vols, 1e-4)

    spot_paths = torch.tensor(paths.T, dtype=torch.float32)
    vol_paths = torch.tensor(vols.T, dtype=torch.float32)

    # ... (Reste du calcul des features identique) ...
    # Feature A: Moneyness
    log_moneyness = torch.log(spot_paths / strike)
    
    # Feature B: Time
    time_grid = torch.linspace(T, 0, steps+1)
    time_feature = time_grid.unsqueeze(0).repeat(batch_size, 1)
    
    # Feature C: Returns (Avec s√©curit√© NaN)
    zeros = torch.zeros((batch_size, 1))
    # On ajoute 1e-6 pour la stabilit√©
    log_returns = torch.diff(torch.log(spot_paths), dim=1)
    log_returns = torch.nan_to_num(log_returns, nan=0.0) # S√©curit√© ultime
    log_returns = torch.cat([zeros, log_returns], dim=1)
    
    # Feature D: Vol
    vol_feature = (vol_paths - 0.2) / 0.1 

    # V√©rifie bien l'ordre : Moneyness, Time, Vol, Returns
    inputs = torch.stack([log_moneyness, time_feature, vol_feature, log_returns], dim=-1)
    
    return spot_paths, inputs

--- Cellule 2 [CODE] ---
# --- PARAM√àTRES ---
S0 = 100; K = 100; T = 1.0; N_STEPS = 30
BATCH_SIZE = 256
LR = 0.001 

# --- CONFIGURATION ---
sim = MarketSimulator(s0=S0, r=0.0, sigma=0.2)
# input_dim=4 (Moneyness, Time, Vol, Returns)
model = DeepHedgingModel(input_dim=4, hidden_dim=32, output_dim=1) 
optimizer = optim.Adam(model.parameters(), lr=LR)
scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='min', factor=0.5, patience=50)

# Aversion au risque plus douce pour commencer
RISK_AVERSION = 1.0 
engine = HedgingEngine(model, optimizer, criterion=None, transaction_cost_pct=0.0, risk_aversion=RISK_AVERSION)

# --- CURRICULUM AVEC WARMUP ---
# (Debut, Fin, Co√ªt, Utiliser_MSE)
phases = [
    (0, 200, 0.0, True),       # WARMUP: Pas de frais, MSE Loss (Stabilisation)
    (200, 1000, 0.001, False), # PHASE 2: Petits frais, Entropic Loss
    (1000, 3000, 0.005, False) # PHASE 3: Vrais frais, Entropic Loss
]

history = []
pbar = tqdm(range(3000))

print("üöÄ D√©marrage (Warmup MSE -> Entropic)...")

for epoch in pbar:
    # 1. Configuration de la phase
    current_cost = 0.0
    use_mse = False
    for start, end, cost, mse_mode in phases:
        if start <= epoch < end:
            current_cost = cost
            use_mse = mse_mode
            break
            
    engine.cost_pct = current_cost
    
    # 2. Donn√©es
    spots, inputs = prepare_batch(sim, BATCH_SIZE, T, N_STEPS, strike=K)
    strikes = torch.full((BATCH_SIZE,), K)
    
    # 3. Premium Initial
    S0_b = spots[:, 0]; Vol0_b = inputs[:, 0, 2]
    bs_p = BlackScholesOracle.get_price(S0_b.numpy(), K, T, 0.0, Vol0_b.numpy(), 'call')
    init_prices = torch.tensor(bs_p, dtype=torch.float32)
    
    # 4. Train Step (Avec le flag use_mse)
    loss, mean_pnl = engine.train_step(spots, strikes, inputs, init_prices, use_mse=use_mse)
    
    if not np.isnan(loss):
        scheduler.step(loss)
        history.append(loss)
    
    if epoch % 10 == 0:
        mode_str = "MSE" if use_mse else "ENT"
        pbar.set_description(f"Ep {epoch}| {mode_str} | C:{current_cost*100:.1f}% | Loss:{loss:.2f} | PnL:{mean_pnl:.2f}")

plt.plot(history)
plt.title("Convergence (Warmup MSE puis Transition Entropique)")
plt.yscale('log')
plt.show()

--- Cellule 3 [CODE] ---
# --- PARAM√àTRES DU TEST ---
N_TEST_PATHS = 2048   # Un grand nombre pour avoir une stat fiable
TEST_BATCH_SIZE = 256 # On proc√®de par batch pour ne pas saturer la RAM
Strike_Test = 100.0

# Listes pour stocker les r√©sultats
all_ai_pnls = []
all_bs_pnls = []

print(f"üöÄ Lancement du Benchmark sur {N_TEST_PATHS} sc√©narios Heston...")

# On s'assure que le mod√®le est en mode √©valuation (fig√©)
model.eval()

# On utilise le moteur actuel pour le calcul de PnL (avec les frais de la Phase 3 !)
# Assure-toi que engine.cost_pct est bien r√©gl√© sur 0.5% (ou la valeur finale)
print(f"   Frais de transaction appliqu√©s : {engine.cost_pct * 100:.2f}%")

with torch.no_grad():
    # Boucle par batch pour g√©n√©rer N_TEST_PATHS
    for _ in tqdm(range(0, N_TEST_PATHS, TEST_BATCH_SIZE)):
        
        # 1. G√©n√©ration donn√©es Heston
        spots, inputs = prepare_batch(sim, TEST_BATCH_SIZE, T, N_STEPS, strike=Strike_Test)
        strikes = torch.full((TEST_BATCH_SIZE,), Strike_Test)
        
        # 2. Calcul du Premium Initial (BS) pour ce batch
        # C'est l'argent re√ßu au d√©part. N√©cessaire pour un PnL juste.
        S0 = spots[:, 0]
        Vol0 = inputs[:, 0, 2] # Volatilit√© initiale fournie par Heston
        
        initial_premiums_np = BlackScholesOracle.get_price(
            S=S0.numpy(), K=Strike_Test, T=T, r=0.0, sigma=Vol0.numpy(), option_type='call'
        )
        initial_premiums = torch.tensor(initial_premiums_np, dtype=torch.float32)
        
        # --- STRAT√âGIE IA ---
        ai_deltas = model(inputs)
        ai_pnl = engine._compute_pnl(spots, strikes, ai_deltas, T, initial_prices=initial_premiums)
        all_ai_pnls.extend(ai_pnl.numpy())
        
        # --- STRAT√âGIE BLACK-SCHOLES (BENCHMARK) ---
        # On recalcule le Delta BS dynamique pour chaque pas de temps
        # Vectorisation pour la vitesse :
        # inputs[:, :, 0] -> LogMoneyness (Pas besoin ici, on a spots)
        # inputs[:, :, 1] -> Time to maturity
        # inputs[:, :, 2] -> Volatilit√© Heston (On donne la vraie vol √† BS pour qu'il soit fort)
        
        bs_deltas_list = []
        for t in range(spots.shape[1]): # Boucle sur le temps (30 pas)
            S_t = spots[:, t].numpy()
            Vol_t = inputs[:, t, 2].numpy() # BS voit la vraie vol
            Time_t = inputs[:, t, 1].numpy()
            
            # Delta BS
            d = BlackScholesOracle.get_delta(S_t, Strike_Test, Time_t, r=0.0, sigma=Vol_t, option_type='call')
            bs_deltas_list.append(d)
            
        # Reconstitution forme [Batch, Time, 1]
        bs_deltas = torch.tensor(np.array(bs_deltas_list)).T.unsqueeze(-1).float()
        
        # Calcul PnL BS (avec les M√äMES frais que l'IA)
        bs_pnl = engine._compute_pnl(spots, strikes, bs_deltas, T, initial_prices=initial_premiums)
        all_bs_pnls.extend(bs_pnl.numpy())

# Conversion en arrays numpy pour l'analyse
all_ai_pnls = np.array(all_ai_pnls)
all_bs_pnls = np.array(all_bs_pnls)

# --- ANALYSE STATISTIQUE ---
mean_ai = np.mean(all_ai_pnls)
std_ai = np.std(all_ai_pnls)
mean_bs = np.mean(all_bs_pnls)
std_bs = np.std(all_bs_pnls)

# Ratio de victoire (Combien de fois l'IA fait mieux que BS ?)
# "Mieux" veut dire un PnL plus √©lev√© (moins de perte ou plus de gain)
wins = np.sum(all_ai_pnls > all_bs_pnls)
win_rate = (wins / len(all_ai_pnls)) * 100

print(f"\nüìä R√âSULTATS COMPARATIFS ({N_TEST_PATHS} sc√©narios)")
print("-" * 50)
print(f"Strat√©gie          | Mean PnL ($) | Std Dev (Risk) | Sharpe Simplifi√©")
print("-" * 50)
print(f"Black-Scholes      | {mean_bs:12.4f} | {std_bs:14.4f} | {mean_bs/std_bs:10.4f}")
print(f"Deep Hedging (IA)  | {mean_ai:12.4f} | {std_ai:14.4f} | {mean_ai/std_ai:10.4f}")
print("-" * 50)
print(f"üèÜ Win Rate de l'IA : {win_rate:.2f}% (L'IA bat BS sur {wins} sc√©narios)")

# --- VISUALISATION ---
plt.figure(figsize=(14, 7))

# Histogrammes superpos√©s
sns.histplot(all_bs_pnls, color='blue', alpha=0.4, label='Black-Scholes', kde=True, stat="density")
sns.histplot(all_ai_pnls, color='red', alpha=0.4, label='Deep Hedging (IA)', kde=True, stat="density")

# Lignes verticales pour les moyennes
plt.axvline(mean_bs, color='blue', linestyle='--', linewidth=2, label=f'Moyenne BS: {mean_bs:.2f}')
plt.axvline(mean_ai, color='red', linestyle='--', linewidth=2, label=f'Moyenne IA: {mean_ai:.2f}')
plt.axvline(0, color='black', linewidth=1) # Z√©ro PnL

plt.title(f"Distribution des PnL (Net de Frais) - {N_TEST_PATHS} Sc√©narios Heston", fontsize=16)
plt.xlabel("Profit & Loss ($)")
plt.ylabel("Densit√© de probabilit√©")
plt.legend()
plt.show()

--- Cellule 4 [CODE] ---


#### FIN DU FICHIER : notebook/projet-3A/notebook/test_LSTM.ipynb ####

#### CONTENU DU FICHIER : notebook/projet-3A/notebook/BlackScholes.ipynb ####
--- Cellule 0 [MARKDOWN] ---
# Black Scholes

--- Cellule 1 [CODE] ---
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

--- Cellule 2 [CODE] ---
def black_scholes_call(S, K, T, r, sigma):
    # 1. Calculate d1
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    
    # 2. Calculate d2
    d2 = d1 - sigma * np.sqrt(T)
    
    # 3. Apply the formula: C = S*N(d1) - K*exp(-rT)*N(d2)
    C = (S * norm.cdf(d1)) - (K * np.exp(-r * T) * norm.cdf(d2))
    
    return C

# Example usage:
spot = 100      # S
strike = 105    # K
time = 1        # T (1 year)
rate = 0.05     # r (5%)
vol = 0.2       # sigma (20%)

price = black_scholes_call(spot, strike, time, rate, vol)
print(f"The fair price of the Call Option (C) is: {price:.2f}")

--- Cellule 3 [CODE] ---
def simulate_stock_path(S0, T, r, sigma, steps):
    dt = T / steps
    # Generate random movements (Brownian Motion increments)
    W = np.random.standard_normal(steps) 
    W = np.cumsum(W) * np.sqrt(dt) # Cumulative sum to get the path
    
    time_steps = np.linspace(0, T, steps)
    # The Black-Scholes dynamic formula
    S_path = S0 * np.exp((r - 0.5 * sigma**2) * time_steps + sigma * W)
    
    return time_steps, S_path

# Visualizing 5 possible futures for the stock
plt.figure(figsize=(10, 6))
for i in range(5):
    t, path = simulate_stock_path(100, 1, 0.05, 0.2, 252)
    plt.plot(t, path)

plt.axhline(y=105, color='r', linestyle='--', label='Strike Price (K)')
plt.title("Simulated Stock Price Paths (S) vs Strike (K)")
plt.xlabel("Time (Years)")
plt.ylabel("Stock Price")
plt.legend()
plt.show()

#### FIN DU FICHIER : notebook/projet-3A/notebook/BlackScholes.ipynb ####

#### CONTENU DU FICHIER : notebook/projet-3A/src/deep_hedger.py ####
#### REMPLACE TOUT LE CONTENU DE : src/deep_hedger.py ####
import torch
import torch.nn as nn

class DeepHedgingModel(nn.Module):
    def __init__(self, input_dim=4, hidden_dim=32, output_dim=1):
        super(DeepHedgingModel, self).__init__()
        self.hidden_dim = hidden_dim
        
        # Normalisation (Batch Norm) pour stabiliser les inputs (Prix vs Temps vs Vol)
        self.bn = nn.BatchNorm1d(input_dim + 1)
        
        self.lstm_cell = nn.LSTMCell(input_size=input_dim + 1, hidden_size=hidden_dim)
        
        self.decision_layer = nn.Sequential(
            nn.Linear(hidden_dim, 32),
            nn.ReLU(),
            nn.Linear(32, output_dim),
            # REMPLACEMENT MAJEUR : Hardtanh au lieu de Sigmoid
            # √áa force la sortie entre 0 et 1 mais garde des gradients forts
            nn.Hardtanh(0.0, 1.0) 
        )

    def forward(self, x, initial_position=None):
        batch_size, seq_len, _ = x.size()
        
        h_t = torch.zeros(batch_size, self.hidden_dim, device=x.device)
        c_t = torch.zeros(batch_size, self.hidden_dim, device=x.device)
        
        if initial_position is None:
            prev_delta = torch.zeros(batch_size, 1, device=x.device)
        else:
            prev_delta = initial_position

        deltas = []
        
        for t in range(seq_len):
            market_features = x[:, t, :]
            
            # Concat√©nation + Normalisation
            combined_input = torch.cat([market_features, prev_delta], dim=1)
            combined_input = self.bn(combined_input)
            
            h_t, c_t = self.lstm_cell(combined_input, (h_t, c_t))
            current_delta = self.decision_layer(h_t)
            
            prev_delta = current_delta
            deltas.append(current_delta)
            
        return torch.stack(deltas, dim=1)
#### FIN DU FICHIER : notebook/projet-3A/src/deep_hedger.py ####

#### CONTENU DU FICHIER : notebook/projet-3A/src/hedging_engine.py ####
#### REMPLACE TOUT LE CONTENU DE : src/hedging_engine.py ####
import torch
import torch.nn as nn
import numpy as np

class HedgingEngine:
    def __init__(self, model, optimizer, criterion, transaction_cost_pct=0.0, risk_aversion=1.0):
        self.model = model
        self.optimizer = optimizer
        self.cost_pct = transaction_cost_pct
        self.risk_aversion = risk_aversion
        # HuberLoss est beaucoup plus stable que MSE pour le d√©but
        self.warmup_criterion = nn.SmoothL1Loss() 

    def _compute_pnl(self, spot_paths, strikes, deltas, T, initial_prices=None):
        price_changes = torch.diff(spot_paths, dim=1)
        active_deltas = deltas[:, :-1, 0]
        
        hedging_pnl = torch.sum(active_deltas * price_changes, dim=1)
        
        # Calcul des frais de transaction
        zeros = torch.zeros((deltas.shape[0], 1, 1), device=deltas.device)
        padded_deltas = torch.cat([zeros, deltas], dim=1)
        delta_changes = torch.abs(torch.diff(padded_deltas, dim=1))
        costs = torch.sum(delta_changes[:, :-1, 0] * spot_paths[:, :-1] * self.cost_pct, dim=1)
        
        final_prices = spot_paths[:, -1]
        option_payoff = torch.relu(final_prices - strikes)
        
        if initial_prices is None:
            initial_prices = torch.zeros_like(option_payoff)
            
        return initial_prices + hedging_pnl - costs - option_payoff

    def entropic_loss(self, pnl):
        # 1. Scaling pour √©viter l'overflow
        # Si le PnL est trop grand, l'exponentielle explose. On clamp.
        x = -self.risk_aversion * pnl
        x = torch.clamp(x, max=80.0) # exp(80) est la limite float32 safe
        
        # 2. LogSumExp Trick
        log_sum_exp = torch.logsumexp(x, dim=0)
        n = torch.tensor(x.size(0), device=x.device, dtype=x.dtype)
        
        return (log_sum_exp - torch.log(n)) / self.risk_aversion

    def train_step(self, spot_paths, strikes, inputs, initial_prices, use_mse=False):
        self.model.train()
        self.optimizer.zero_grad()
        
        deltas = self.model(inputs)
        pnl = self._compute_pnl(spot_paths, strikes, deltas, T=1.0, initial_prices=initial_prices)
        
        # S√©curit√© Anti-NaN
        if torch.isnan(pnl).any():
            pnl = torch.nan_to_num(pnl, nan=0.0)

        if use_mse:
            # On utilise SmoothL1 au lieu de MSE pure pour √©viter l'explosion
            # On vise PnL = 0 (Perfect Hedge)
            target = torch.zeros_like(pnl)
            loss = self.warmup_criterion(pnl, target)
        else:
            loss = self.entropic_loss(pnl)
        
        if torch.isnan(loss):
            return 0.0, 0.0 # On skip le step si NaN
            
        loss.backward()
        
        # Clipping tr√®s agressif pour forcer la stabilit√©
        torch.nn.utils.clip_grad_norm_(self.model.parameters(), max_norm=0.1)
        
        self.optimizer.step()
        
        return loss.item(), torch.mean(pnl).item()
#### FIN DU FICHIER : notebook/projet-3A/src/hedging_engine.py ####

#### CONTENU DU FICHIER : notebook/projet-3A/src/analytics_models.py ####
import numpy as np
from scipy.stats import norm

class BlackScholesOracle:
    """
    L'Oracle : Impl√©mente la formule ferm√©e de Black-Scholes pour le pricing.
    Supporte la vectorisation (entr√©es sous forme de tableaux NumPy).
    """
    
    @staticmethod
    def get_price(S, K, T, r, sigma, option_type='call'):
        """
        Calcule le prix d'une option europ√©enne.
        
        Args:
            S (float or array): Prix actuel du sous-jacent (Spot)
            K (float or array): Prix d'exercice (Strike)
            T (float or array): Temps restant jusqu'√† maturit√© (en ann√©es)
            r (float or array): Taux d'int√©r√™t sans risque
            sigma (float or array): Volatilit√© du sous-jacent
            option_type (str): 'call' ou 'put'
            
        Returns:
            float or array: Prix de l'option
        """
        # Pour √©viter la division par z√©ro si T=0
        T = np.maximum(T, 1e-8)
        
        # Calcul de d1 et d2
        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)
        
        if option_type.lower() == 'call':
            price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
        elif option_type.lower() == 'put':
            price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
        else:
            raise ValueError("option_type doit √™tre 'call' ou 'put'")
            
        return price

    @staticmethod
    def get_delta(S, K, T, r, sigma, option_type='call'):
        """
        Calcule le Delta de l'option (utile pour la comparaison en Semaine 3).
        Delta = dV/dS (sensibilit√© du prix de l'option au prix du sous-jacent).
        """
        T = np.maximum(T, 1e-8)
        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        
        if option_type.lower() == 'call':
            return norm.cdf(d1)
        else:
            return norm.cdf(d1) - 1

# --- Petit script de test ---
if __name__ == "__main__":
    # Test unitaire
    S, K, T, r, sigma = 100, 100, 1, 0.05, 0.2
    
    call_price = BlackScholesOracle.get_price(S, K, T, r, sigma, 'call')
    put_price = BlackScholesOracle.get_price(S, K, T, r, sigma, 'put')
    delta_call = BlackScholesOracle.get_delta(S, K, T, r, sigma, 'call')
    
    print(f"Test pour S=100, K=100, T=1an, r=5%, sigma=20%:")
    print(f"  - Prix du Call : {call_price:.4f}")
    print(f"  - Prix du Put  : {put_price:.4f}")
    print(f"  - Delta du Call: {delta_call:.4f}")

    # Test de vectorisation (calculer 3 prix d'un coup)
    S_vec = np.array([90, 100, 110])
    prices = BlackScholesOracle.get_price(S_vec, K, T, r, sigma)
    print(f"\nTest vectorisation (3 prix) : {prices}")
#### FIN DU FICHIER : notebook/projet-3A/src/analytics_models.py ####

#### CONTENU DU FICHIER : notebook/projet-3A/src/market_simulator.py ####
import numpy as np

class MarketSimulator:
    """
    Simulateur de prix d'actifs financiers.
    """
    def __init__(self, s0, r, sigma, dt=1/252):
        self.s0 = s0          # Prix initial de l'action
        self.r = r            # Taux sans risque (ex: 0.03 pour 3%)
        self.sigma = sigma    # Volatilit√© (ex: 0.2 pour 20%)
        self.dt = dt          # Pas de temps (1/252 = 1 jour de bourse)

    def simulate_gbm(self, steps, n_paths=1):
        """
        G√©n√®re des trajectoires via le Mouvement Brownien G√©om√©trique (GBM).
        Formule : dS_t = r*S_t*dt + sigma*S_t*dW_t
        """
        # G√©n√©ration des chocs al√©atoires normaux (dW_t)
        # Taille : (Nombre de pas, Nombre de trajectoires)
        z = np.random.standard_normal((steps, n_paths))
        
        # Calcul de la d√©rive et de la diffusion
        # On utilise la forme exponentielle : S_t = S_0 * exp((r - 0.5*sigma^2)*t + sigma*W_t)
        drift = (self.r - 0.5 * self.sigma**2) * self.dt
        diffusion = self.sigma * np.sqrt(self.dt) * z
        
        # Calcul des rendements logarithmiques cumul√©s
        log_returns = drift + diffusion
        cum_log_returns = np.cumsum(log_returns, axis=0)
        
        # Ajout du prix initial (log(S0)) et passage √† l'exponentielle
        paths = self.s0 * np.exp(np.vstack([np.zeros(n_paths), cum_log_returns]))
        
        return paths
    
    def simulate_heston(self, steps, n_paths=1, kappa=2.0, theta=0.2, xi=0.3, rho=-0.7):
        """
        Simule le mod√®le de Heston (Volatilit√© Stochastique).
        
        Args:
            kappa (float): Vitesse de retour √† la moyenne de la volatilit√©.
            theta (float): Volatilit√© moyenne √† long terme.
            xi (float): "Volatilit√© de la volatilit√©" (nervosit√© du march√©).
            rho (float): Corr√©lation entre le prix et la volatilit√© (Souvent n√©gative : quand le prix chute, la peur monte).
        
        Returns:
            paths (ndarray): Prix de l'actif [steps+1, n_paths]
            vol_paths (ndarray): Volatilit√© instantan√©e [steps+1, n_paths]
        """
        # 1. G√©n√©ration des chocs al√©atoires corr√©l√©s
        # Z1 pour le prix, Z2 pour la volatilit√©
        z1 = np.random.standard_normal((steps, n_paths))
        z2_uncorrelated = np.random.standard_normal((steps, n_paths))
        # Corr√©lation des browniens : W2 = rho*W1 + sqrt(1-rho^2)*Z2
        z2 = rho * z1 + np.sqrt(1 - rho**2) * z2_uncorrelated

        # 2. Initialisation des tableaux
        # On a besoin de stocker la volatilit√© √† chaque instant
        price_paths = np.zeros((steps + 1, n_paths))
        vol_paths = np.zeros((steps + 1, n_paths))
        
        # Conditions initiales
        price_paths[0] = self.s0
        vol_paths[0] = theta # On commence √† la moyenne long terme (ex: 20%)

        dt = self.dt
        sqrt_dt = np.sqrt(dt)

        # 3. Boucle temporelle (Euler-Maruyama)
        # On ne peut pas tout vectoriser d'un coup car t d√©pend de t-1
        for t in range(steps):
            S_t = price_paths[t]
            v_t = vol_paths[t]
            
            # S'assurer que la variance reste positive (Absorbtion ou R√©flexion)
            v_t = np.maximum(v_t, 1e-5) # S√©curit√© num√©rique
            sqrt_vt = np.sqrt(v_t)

            # Mise √† jour de la Volatilit√© (Processus CIR)
            # dv = kappa * (theta - v) * dt + xi * sqrt(v) * dW_vol
            d_vol = kappa * (theta - v_t) * dt + xi * sqrt_vt * z2[t] * sqrt_dt
            vol_paths[t+1] = v_t + d_vol
            
            # Mise √† jour du Prix
            # dS = r * S * dt + sqrt(v) * S * dW_price
            d_price = self.r * S_t * dt + sqrt_vt * S_t * z1[t] * sqrt_dt
            price_paths[t+1] = S_t + d_price

        # On retourne les prix ET les volatilit√©s (car le LSTM aura besoin de voir la vol)
        return price_paths, np.sqrt(np.maximum(vol_paths, 1e-5))

# Exemple d'utilisation rapide pour tester :
if __name__ == "__main__":
    sim = MarketSimulator(s0=100, r=0.05, sigma=0.2)
    # Simuler 10 trajectoires sur 252 jours (1 an)
    trajectoires = sim.simulate_gbm(steps=252, n_paths=10)
    print(f"Forme de la matrice de sortie : {trajectoires.shape}") # (253, 10)
    print(f"Prix finaux des 5 premi√®res trajectoires : {trajectoires[-1, :5]}")
#### FIN DU FICHIER : notebook/projet-3A/src/market_simulator.py ####

#### CONTENU DU FICHIER : src/deep_hedger.py ####
#### REMPLACE TOUT LE CONTENU DE : src/deep_hedger.py ####
import torch
import torch.nn as nn

class DeepHedgingModel(nn.Module):
    def __init__(self, input_dim=4, hidden_dim=32, output_dim=1):
        super(DeepHedgingModel, self).__init__()
        self.hidden_dim = hidden_dim
        
        # Normalisation (Batch Norm) pour stabiliser les inputs (Prix vs Temps vs Vol)
        self.bn = nn.BatchNorm1d(input_dim + 1)
        
        self.lstm_cell = nn.LSTMCell(input_size=input_dim + 1, hidden_size=hidden_dim)
        
        self.decision_layer = nn.Sequential(
            nn.Linear(hidden_dim, 32),
            nn.ReLU(),
            nn.Linear(32, output_dim),
            # REMPLACEMENT MAJEUR : Hardtanh au lieu de Sigmoid
            # √áa force la sortie entre 0 et 1 mais garde des gradients forts
            nn.Hardtanh(0.0, 1.0) 
        )

    def forward(self, x, initial_position=None):
        batch_size, seq_len, _ = x.size()
        
        h_t = torch.zeros(batch_size, self.hidden_dim, device=x.device)
        c_t = torch.zeros(batch_size, self.hidden_dim, device=x.device)
        
        if initial_position is None:
            prev_delta = torch.zeros(batch_size, 1, device=x.device)
        else:
            prev_delta = initial_position

        deltas = []
        
        for t in range(seq_len):
            market_features = x[:, t, :]
            
            # Concat√©nation + Normalisation
            combined_input = torch.cat([market_features, prev_delta], dim=1)
            combined_input = self.bn(combined_input)
            
            h_t, c_t = self.lstm_cell(combined_input, (h_t, c_t))
            current_delta = self.decision_layer(h_t)
            
            prev_delta = current_delta
            deltas.append(current_delta)
            
        return torch.stack(deltas, dim=1)
#### FIN DU FICHIER : src/deep_hedger.py ####

#### CONTENU DU FICHIER : src/hedging_engine.py ####
#### REMPLACE TOUT LE CONTENU DE : src/hedging_engine.py ####
import torch
import torch.nn as nn
import numpy as np

class HedgingEngine:
    def __init__(self, model, optimizer, criterion, transaction_cost_pct=0.0, risk_aversion=1.0):
        self.model = model
        self.optimizer = optimizer
        self.cost_pct = transaction_cost_pct
        self.risk_aversion = risk_aversion
        # HuberLoss est beaucoup plus stable que MSE pour le d√©but
        self.warmup_criterion = nn.SmoothL1Loss() 

    def _compute_pnl(self, spot_paths, strikes, deltas, T, initial_prices=None):
        price_changes = torch.diff(spot_paths, dim=1)
        active_deltas = deltas[:, :-1, 0]
        
        hedging_pnl = torch.sum(active_deltas * price_changes, dim=1)
        
        # Calcul des frais de transaction
        zeros = torch.zeros((deltas.shape[0], 1, 1), device=deltas.device)
        padded_deltas = torch.cat([zeros, deltas], dim=1)
        delta_changes = torch.abs(torch.diff(padded_deltas, dim=1))
        costs = torch.sum(delta_changes[:, :-1, 0] * spot_paths[:, :-1] * self.cost_pct, dim=1)
        
        final_prices = spot_paths[:, -1]
        option_payoff = torch.relu(final_prices - strikes)
        
        if initial_prices is None:
            initial_prices = torch.zeros_like(option_payoff)
            
        return initial_prices + hedging_pnl - costs - option_payoff

    def entropic_loss(self, pnl):
        # 1. Scaling pour √©viter l'overflow
        # Si le PnL est trop grand, l'exponentielle explose. On clamp.
        x = -self.risk_aversion * pnl
        x = torch.clamp(x, max=80.0) # exp(80) est la limite float32 safe
        
        # 2. LogSumExp Trick
        log_sum_exp = torch.logsumexp(x, dim=0)
        n = torch.tensor(x.size(0), device=x.device, dtype=x.dtype)
        
        return (log_sum_exp - torch.log(n)) / self.risk_aversion

    def train_step(self, spot_paths, strikes, inputs, initial_prices, use_mse=False):
        self.model.train()
        self.optimizer.zero_grad()
        
        deltas = self.model(inputs)
        pnl = self._compute_pnl(spot_paths, strikes, deltas, T=1.0, initial_prices=initial_prices)
        
        # S√©curit√© Anti-NaN
        if torch.isnan(pnl).any():
            pnl = torch.nan_to_num(pnl, nan=0.0)

        if use_mse:
            # On utilise SmoothL1 au lieu de MSE pure pour √©viter l'explosion
            # On vise PnL = 0 (Perfect Hedge)
            target = torch.zeros_like(pnl)
            loss = self.warmup_criterion(pnl, target)
        else:
            loss = self.entropic_loss(pnl)
        
        if torch.isnan(loss):
            return 0.0, 0.0 # On skip le step si NaN
            
        loss.backward()
        
        # Clipping tr√®s agressif pour forcer la stabilit√©
        torch.nn.utils.clip_grad_norm_(self.model.parameters(), max_norm=0.1)
        
        self.optimizer.step()
        
        return loss.item(), torch.mean(pnl).item()
#### FIN DU FICHIER : src/hedging_engine.py ####

#### CONTENU DU FICHIER : src/analytics_models.py ####
import numpy as np
from scipy.stats import norm

class BlackScholesOracle:
    """
    L'Oracle : Impl√©mente la formule ferm√©e de Black-Scholes pour le pricing.
    Supporte la vectorisation (entr√©es sous forme de tableaux NumPy).
    """
    
    @staticmethod
    def get_price(S, K, T, r, sigma, option_type='call'):
        """
        Calcule le prix d'une option europ√©enne.
        
        Args:
            S (float or array): Prix actuel du sous-jacent (Spot)
            K (float or array): Prix d'exercice (Strike)
            T (float or array): Temps restant jusqu'√† maturit√© (en ann√©es)
            r (float or array): Taux d'int√©r√™t sans risque
            sigma (float or array): Volatilit√© du sous-jacent
            option_type (str): 'call' ou 'put'
            
        Returns:
            float or array: Prix de l'option
        """
        # Pour √©viter la division par z√©ro si T=0
        T = np.maximum(T, 1e-8)
        
        # Calcul de d1 et d2
        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)
        
        if option_type.lower() == 'call':
            price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
        elif option_type.lower() == 'put':
            price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
        else:
            raise ValueError("option_type doit √™tre 'call' ou 'put'")
            
        return price

    @staticmethod
    def get_delta(S, K, T, r, sigma, option_type='call'):
        """
        Calcule le Delta de l'option (utile pour la comparaison en Semaine 3).
        Delta = dV/dS (sensibilit√© du prix de l'option au prix du sous-jacent).
        """
        T = np.maximum(T, 1e-8)
        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        
        if option_type.lower() == 'call':
            return norm.cdf(d1)
        else:
            return norm.cdf(d1) - 1

# --- Petit script de test ---
if __name__ == "__main__":
    # Test unitaire
    S, K, T, r, sigma = 100, 100, 1, 0.05, 0.2
    
    call_price = BlackScholesOracle.get_price(S, K, T, r, sigma, 'call')
    put_price = BlackScholesOracle.get_price(S, K, T, r, sigma, 'put')
    delta_call = BlackScholesOracle.get_delta(S, K, T, r, sigma, 'call')
    
    print(f"Test pour S=100, K=100, T=1an, r=5%, sigma=20%:")
    print(f"  - Prix du Call : {call_price:.4f}")
    print(f"  - Prix du Put  : {put_price:.4f}")
    print(f"  - Delta du Call: {delta_call:.4f}")

    # Test de vectorisation (calculer 3 prix d'un coup)
    S_vec = np.array([90, 100, 110])
    prices = BlackScholesOracle.get_price(S_vec, K, T, r, sigma)
    print(f"\nTest vectorisation (3 prix) : {prices}")
#### FIN DU FICHIER : src/analytics_models.py ####

#### CONTENU DU FICHIER : src/market_simulator.py ####
import numpy as np

class MarketSimulator:
    """
    Simulateur de prix d'actifs financiers.
    """
    def __init__(self, s0, r, sigma, dt=1/252):
        self.s0 = s0          # Prix initial de l'action
        self.r = r            # Taux sans risque (ex: 0.03 pour 3%)
        self.sigma = sigma    # Volatilit√© (ex: 0.2 pour 20%)
        self.dt = dt          # Pas de temps (1/252 = 1 jour de bourse)

    def simulate_gbm(self, steps, n_paths=1):
        """
        G√©n√®re des trajectoires via le Mouvement Brownien G√©om√©trique (GBM).
        Formule : dS_t = r*S_t*dt + sigma*S_t*dW_t
        """
        # G√©n√©ration des chocs al√©atoires normaux (dW_t)
        # Taille : (Nombre de pas, Nombre de trajectoires)
        z = np.random.standard_normal((steps, n_paths))
        
        # Calcul de la d√©rive et de la diffusion
        # On utilise la forme exponentielle : S_t = S_0 * exp((r - 0.5*sigma^2)*t + sigma*W_t)
        drift = (self.r - 0.5 * self.sigma**2) * self.dt
        diffusion = self.sigma * np.sqrt(self.dt) * z
        
        # Calcul des rendements logarithmiques cumul√©s
        log_returns = drift + diffusion
        cum_log_returns = np.cumsum(log_returns, axis=0)
        
        # Ajout du prix initial (log(S0)) et passage √† l'exponentielle
        paths = self.s0 * np.exp(np.vstack([np.zeros(n_paths), cum_log_returns]))
        
        return paths
    
    def simulate_heston(self, steps, n_paths=1, kappa=2.0, theta=0.2, xi=0.3, rho=-0.7):
        """
        Simule le mod√®le de Heston (Volatilit√© Stochastique).
        
        Args:
            kappa (float): Vitesse de retour √† la moyenne de la volatilit√©.
            theta (float): Volatilit√© moyenne √† long terme.
            xi (float): "Volatilit√© de la volatilit√©" (nervosit√© du march√©).
            rho (float): Corr√©lation entre le prix et la volatilit√© (Souvent n√©gative : quand le prix chute, la peur monte).
        
        Returns:
            paths (ndarray): Prix de l'actif [steps+1, n_paths]
            vol_paths (ndarray): Volatilit√© instantan√©e [steps+1, n_paths]
        """
        # 1. G√©n√©ration des chocs al√©atoires corr√©l√©s
        # Z1 pour le prix, Z2 pour la volatilit√©
        z1 = np.random.standard_normal((steps, n_paths))
        z2_uncorrelated = np.random.standard_normal((steps, n_paths))
        # Corr√©lation des browniens : W2 = rho*W1 + sqrt(1-rho^2)*Z2
        z2 = rho * z1 + np.sqrt(1 - rho**2) * z2_uncorrelated

        # 2. Initialisation des tableaux
        # On a besoin de stocker la volatilit√© √† chaque instant
        price_paths = np.zeros((steps + 1, n_paths))
        vol_paths = np.zeros((steps + 1, n_paths))
        
        # Conditions initiales
        price_paths[0] = self.s0
        vol_paths[0] = theta # On commence √† la moyenne long terme (ex: 20%)

        dt = self.dt
        sqrt_dt = np.sqrt(dt)

        # 3. Boucle temporelle (Euler-Maruyama)
        # On ne peut pas tout vectoriser d'un coup car t d√©pend de t-1
        for t in range(steps):
            S_t = price_paths[t]
            v_t = vol_paths[t]
            
            # S'assurer que la variance reste positive (Absorbtion ou R√©flexion)
            v_t = np.maximum(v_t, 1e-5) # S√©curit√© num√©rique
            sqrt_vt = np.sqrt(v_t)

            # Mise √† jour de la Volatilit√© (Processus CIR)
            # dv = kappa * (theta - v) * dt + xi * sqrt(v) * dW_vol
            d_vol = kappa * (theta - v_t) * dt + xi * sqrt_vt * z2[t] * sqrt_dt
            vol_paths[t+1] = v_t + d_vol
            
            # Mise √† jour du Prix
            # dS = r * S * dt + sqrt(v) * S * dW_price
            d_price = self.r * S_t * dt + sqrt_vt * S_t * z1[t] * sqrt_dt
            price_paths[t+1] = S_t + d_price

        # On retourne les prix ET les volatilit√©s (car le LSTM aura besoin de voir la vol)
        return price_paths, np.sqrt(np.maximum(vol_paths, 1e-5))

# Exemple d'utilisation rapide pour tester :
if __name__ == "__main__":
    sim = MarketSimulator(s0=100, r=0.05, sigma=0.2)
    # Simuler 10 trajectoires sur 252 jours (1 an)
    trajectoires = sim.simulate_gbm(steps=252, n_paths=10)
    print(f"Forme de la matrice de sortie : {trajectoires.shape}") # (253, 10)
    print(f"Prix finaux des 5 premi√®res trajectoires : {trajectoires[-1, :5]}")
#### FIN DU FICHIER : src/market_simulator.py ####

