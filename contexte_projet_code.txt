### STRUCTURE COMPLÈTE DU PROJET ###
projet_sauvetage/
    requirements.txt
    .gitignore
    main.py
    code_to_text.py
    notebook/
        Data_Load.ipynb
        BlackScholes.ipynb
    data/
        data.csv
    src/
        analytics_models.py
        data_BS.py
        market_simulator.py

==================================================

#### CONTENU DU FICHIER : main.py ####

#### FIN DU FICHIER : main.py ####

#### CONTENU DU FICHIER : code_to_text.py ####
import os
import json
import nbformat

# --- Configuration ---
# Dossiers et fichiers système à ignorer
IGNORE_LIST = {
    '.git', '__pycache__', 'venv', '.venv', 'node_modules', 
    '.ipynb_checkpoints', '.DS_Store', 'contexte_projet.txt', 
    'contexte_projet_notebooks.txt', 'contexte_projet_code.txt', # On s'ignore soi-même pour éviter une boucle
    '.idea', '.vscode'
}

OUTPUT_FILE = "contexte_projet_code.txt"

def extract_notebook_content(filepath):
    """
    Lit un fichier .ipynb avec nbformat et extrait uniquement 
    les cellules de type CODE et MARKDOWN.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            nb = nbformat.read(f, as_version=4)
            content = []
            for i, cell in enumerate(nb.cells):
                cell_type = cell.cell_type.upper()
                source = cell.source
                content.append(f"--- Cellule {i} [{cell_type}] ---\n{source}\n")
            return "\n".join(content)
    except Exception as e:
        return f"[Erreur lors de la lecture du Notebook : {e}]\n"

def extract_py_content(filepath):
    """
    Lit simplement le contenu textuel d'un fichier .py
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"[Erreur lors de la lecture du fichier Python : {e}]\n"

def generate_context_file(root_dir, output_file):
    with open(output_file, 'w', encoding='utf-8') as f_out:
        
        # --- 1. GÉNÉRATION DE L'ARBORESCENCE COMPLÈTE ---
        f_out.write("### STRUCTURE COMPLÈTE DU PROJET ###\n")
        
        for root, dirs, files in os.walk(root_dir):
            dirs[:] = [d for d in dirs if d not in IGNORE_LIST]
            
            level = root.replace(root_dir, '').count(os.sep)
            indent = ' ' * 4 * level
            
            f_out.write(f"{indent}{os.path.basename(root)}/\n")
            
            sub_indent = ' ' * 4 * (level + 1)
            for f in files:
                if f not in IGNORE_LIST:
                    f_out.write(f"{sub_indent}{f}\n")
        
        f_out.write("\n" + "="*50 + "\n\n")

        # --- 2. EXTRACTION DU CONTENU (.ipynb ET .py) ---
        for root, dirs, files in os.walk(root_dir):
            dirs[:] = [d for d in dirs if d not in IGNORE_LIST]
            
            for file in files:
                full_path = os.path.join(root, file)
                relative_path = os.path.relpath(full_path, root_dir)
                
                # Gestion des Notebooks
                if file.endswith('.ipynb'):
                    f_out.write(f"#### CONTENU DU FICHIER : {relative_path} ####\n")
                    f_out.write(extract_notebook_content(full_path))
                    f_out.write(f"\n#### FIN DU FICHIER : {relative_path} ####\n\n")
                
                # Gestion des fichiers Python standards
                elif file.endswith('.py'):
                    f_out.write(f"#### CONTENU DU FICHIER : {relative_path} ####\n")
                    f_out.write(extract_py_content(full_path))
                    f_out.write(f"\n#### FIN DU FICHIER : {relative_path} ####\n\n")

if __name__ == "__main__":
    chemin_actuel = os.getcwd()
    print(f"Analyse du projet dans : {chemin_actuel}")
    print(f"1. Génération de l'arborescence complète.")
    print(f"2. Extraction du code des fichiers .ipynb et .py.")
    
    generate_context_file(chemin_actuel, OUTPUT_FILE)
    
    print(f"Terminé ! Le fichier '{OUTPUT_FILE}' a été généré.")
#### FIN DU FICHIER : code_to_text.py ####

#### CONTENU DU FICHIER : notebook/Data_Load.ipynb ####
[Erreur lors de la lecture du Notebook : Notebook does not appear to be JSON: '']

#### FIN DU FICHIER : notebook/Data_Load.ipynb ####

#### CONTENU DU FICHIER : notebook/BlackScholes.ipynb ####
--- Cellule 0 [MARKDOWN] ---
# Black Scholes

--- Cellule 1 [CODE] ---
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

--- Cellule 2 [CODE] ---
def black_scholes_call(S, K, T, r, sigma):
    # 1. Calculate d1
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    
    # 2. Calculate d2
    d2 = d1 - sigma * np.sqrt(T)
    
    # 3. Apply the formula: C = S*N(d1) - K*exp(-rT)*N(d2)
    C = (S * norm.cdf(d1)) - (K * np.exp(-r * T) * norm.cdf(d2))
    
    return C

# Example usage:
spot = 100      # S
strike = 105    # K
time = 1        # T (1 year)
rate = 0.05     # r (5%)
vol = 0.2       # sigma (20%)

price = black_scholes_call(spot, strike, time, rate, vol)
print(f"The fair price of the Call Option (C) is: {price:.2f}")

--- Cellule 3 [CODE] ---
def simulate_stock_path(S0, T, r, sigma, steps):
    dt = T / steps
    # Generate random movements (Brownian Motion increments)
    W = np.random.standard_normal(steps) 
    W = np.cumsum(W) * np.sqrt(dt) # Cumulative sum to get the path
    
    time_steps = np.linspace(0, T, steps)
    # The Black-Scholes dynamic formula
    S_path = S0 * np.exp((r - 0.5 * sigma**2) * time_steps + sigma * W)
    
    return time_steps, S_path

# Visualizing 5 possible futures for the stock
plt.figure(figsize=(10, 6))
for i in range(5):
    t, path = simulate_stock_path(100, 1, 0.05, 0.2, 252)
    plt.plot(t, path)

plt.axhline(y=105, color='r', linestyle='--', label='Strike Price (K)')
plt.title("Simulated Stock Price Paths (S) vs Strike (K)")
plt.xlabel("Time (Years)")
plt.ylabel("Stock Price")
plt.legend()
plt.show()

#### FIN DU FICHIER : notebook/BlackScholes.ipynb ####

#### CONTENU DU FICHIER : src/analytics_models.py ####

#### FIN DU FICHIER : src/analytics_models.py ####

#### CONTENU DU FICHIER : src/data_BS.py ####

#### FIN DU FICHIER : src/data_BS.py ####

#### CONTENU DU FICHIER : src/market_simulator.py ####
import numpy as np

class MarketSimulator:
    """
    Simulateur de prix d'actifs financiers.
    """
    def __init__(self, s0, r, sigma, dt=1/252):
        self.s0 = s0          # Prix initial de l'action
        self.r = r            # Taux sans risque (ex: 0.03 pour 3%)
        self.sigma = sigma    # Volatilité (ex: 0.2 pour 20%)
        self.dt = dt          # Pas de temps (1/252 = 1 jour de bourse)

    def simulate_gbm(self, steps, n_paths=1):
        """
        Génère des trajectoires via le Mouvement Brownien Géométrique (GBM).
        Formule : dS_t = r*S_t*dt + sigma*S_t*dW_t
        """
        # Génération des chocs aléatoires normaux (dW_t)
        # Taille : (Nombre de pas, Nombre de trajectoires)
        z = np.random.standard_normal((steps, n_paths))
        
        # Calcul de la dérive et de la diffusion
        # On utilise la forme exponentielle : S_t = S_0 * exp((r - 0.5*sigma^2)*t + sigma*W_t)
        drift = (self.r - 0.5 * self.sigma**2) * self.dt
        diffusion = self.sigma * np.sqrt(self.dt) * z
        
        # Calcul des rendements logarithmiques cumulés
        log_returns = drift + diffusion
        cum_log_returns = np.cumsum(log_returns, axis=0)
        
        # Ajout du prix initial (log(S0)) et passage à l'exponentielle
        paths = self.s0 * np.exp(np.vstack([np.zeros(n_paths), cum_log_returns]))
        
        return paths

# Exemple d'utilisation rapide pour tester :
if __name__ == "__main__":
    sim = MarketSimulator(s0=100, r=0.05, sigma=0.2)
    # Simuler 10 trajectoires sur 252 jours (1 an)
    trajectoires = sim.simulate_gbm(steps=252, n_paths=10)
    print(f"Forme de la matrice de sortie : {trajectoires.shape}") # (253, 10)
    print(f"Prix finaux des 5 premières trajectoires : {trajectoires[-1, :5]}")
#### FIN DU FICHIER : src/market_simulator.py ####

